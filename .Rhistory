install.packages('flipPlots')
install.packages('flipData', 'flipFormat', 'flipChartBasics')
install.packages('flipData')
install.packages(flipFormat')
q
quit()
)
''
install.packages('flipFormat')
install.packages('installr')
library(installr)
updateR()
library(devtools)
install_github('andreacirilloac/updateR')
library(updateR)
updateR(admin_password = 'profit is its own reward')
updateR()
library(dplyr)
library(docstring)
trim <- function(table, p = 0.1) {
#' Trimmed mean
#'
#' Trim the top and bottom (p*100)% of forecasts
#'
#' @param table The processed question data table (needs to have a forecast column)
#' @param p The proportion of forecasts to trim from each end (between 0 and 1)
#' @return The trimmed mean
table <- table %>% arrange(forecast)
trimN <- round(p * nrow(table))
browser()
lastRow <- nrow(table) - trimN
trimTable <- table[(trimN + 1):lastRow, ]
trimmedMean <- mean(trimTable[["forecast"]])
return(trimmedMean)
}
df <- data.table(forecast = c(rep(.1, 5), rep(.2, 5), rep(.4, 5),
rep(.5, 3), rep(1.0, 2)))
library(data.table)
df <- data.table(forecast = c(rep(.1, 5), rep(.2, 5), rep(.4, 5),
rep(.5, 3), rep(1.0, 2)))
trim(df)
library(devtools)
getwd()
setwd('fri/xpt')
devtools::check()
devtools::test()
devtools::test()
devtools::test()
devtools::install()
library(xpt)
fff <- c(0.1, 0.1, .2, .3, .9, .8, .9, .4, .444)
neymanAggCalc(fff)
identical(specific_function, neymanAggCalc)
q
q
c
devtools::install()
library(xpt)
forecasts <- c(rep(.1, 5), rep(.2, 5), rep(.4, 5), rep(.5, 2), rep(.9, 2), 1.0)
neymanAggCalc(forecasts)
devtools::test()
devtools::install()
devtools::install()
devtools::test()
hd_trim <- function(x, p = 0.1, drop_zeroes = FALSE) {
  #' High-Density Trimming/Winsorizing
  #'
  #' @description This code comes from an email from Ben Powell.
  #'
  #' You find the shortest interval containing (1-p) * 100% of the data and take the
  #' mean of the forecasts within that interval.
  #'
  #' @note As p gets bigger this acts like a mode in a similar way to
  #' the symmetrically-trimmed mean acting like a median.
  #'
  #' @param x A vector of forecasts
  #' @param p The proportion of forecasts to trim (between 0 and 1)
  #' @param drop_zeroes Whether to drop zeroes from the vector
  #'
  #' @export
  x <- preprocess(x, q = 0, drop_zeroes)
  browser()
  n_out <- floor(length(x) * p)
  n_in <- length(x) - n_out
  d <- c()
  for (i in 1:(n_out + 1)) {
    d[i] <- x[i + n_in - 1] - x[i]
  }
  i <- which.min(d)
  mean(x[i:(i + n_in - 1)])
}
forecasts <- c(rep(.1, 5), rep(.2, 5), rep(.4, 5), rep(.5, 2), rep(.9, 2), 1.0)
hd_trim(forecasts)
x
c
not <- 1 - forecasts
hd_trim(not)
x
c
hd_trim(not*100)
x
length(x)
c
hd_trim(forecast * 100)
hd_trim(forecasts * 100)
x
length(x)
n
n
n
n
n
n
n
n
n_out
c
hd_trim(not * 100)
c
hd_trim(not * 100)
n
n
n_out
n_in
n
n_in
q
c
hd_trim(forecasts * 100)
n
n
n
n_out
n_in
q
c
devtools::document()
rm()
devtools::document()
